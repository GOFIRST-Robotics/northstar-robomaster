/*****************************************************************************/
/********** !!! WARNING: CODE GENERATED BY TAPROOT. DO NOT EDIT !!! **********/
/*****************************************************************************/

/*****************************************************************************/
/********** !!! WARNING: CODE GENERATED BY TAPROOT. DO NOT EDIT !!! **********/
/*****************************************************************************/
//TOD: Add inversion logic
/*
 * Copyright (c) 2020-2021 Advanced Robotics at the University of Washington <robomstr@uw.edu>
 *
 * This file is part of Taproot.
 *
 * Taproot is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Taproot is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Taproot.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef TAPROOT_REV_MOTOR_HPP_
#define TAPROOT_REV_MOTOR_HPP_

#include <string>
#include <queue>
#include <utility>

#include "tap/architecture/timeout.hpp"
#include "tap/communication/can/can_rx_listener.hpp"



namespace tap::motor
{
/**
 * CAN IDs for the feedback messages sent by DJI motor controllers. Motor `i` in the set
 * {1, 2,...,8} sends feedback data with in a CAN message with ID 0x200 + `i`.
 * for declaring a new motor, must be one of these motor
 * identifiers
 */
enum REVMotorId : uint32_t
{
    REV_MOTOR1 = 0x001,
    REV_MOTOR2 = 0x002,
    REV_MOTOR3 = 0x003,
    REV_MOTOR4 = 0x004,
    REV_MOTOR5 = 0x005,
    REV_MOTOR6 = 0x006,
    REV_MOTOR7 = 0x007,
    REV_MOTOR8 = 0x008,
};

enum class APICommand : uint16_t
{
    ClearFaults     = (6 << 4) | 14,
    FactoryDefaults = (7 << 4) | 4,
    FactoryReset    = (7 << 4) | 5,
    Identify        = (7 << 4) | 6,
    Heartbeat       = (11 << 4) | 2,
    BurnFlash       = (63 << 4) | 2,
    FirmwareVersion = (9 << 4) | 8,

    Setpoint        = (0 << 4) | 1,
    DutyCycle       = (0 << 4) | 2,
    Velocity        = (1 << 4) | 2,
    SmartVelocity   = (1 << 4) | 3,
    Position        = (3 << 4) | 2,
    Voltage         = (4 << 4) | 2,
    Current         = (4 << 4) | 3,
    SmartMotion     = (5 << 4) | 2,

    Period0         = (6 << 4) | 0,
    Period1         = (6 << 4) | 1,
    Period2         = (6 << 4) | 2,
    Period3         = (6 << 4) | 3,
    Period4         = (6 << 4) | 4
};

enum class Parameter : uint32_t
{
    kInputMode = 1,
    kMotorType = 2,
    kCommAdvance = 3,
    kSensorType = 4,
    kCtrlType = 5,
    kIdleMode = 6,
    kInputDeadband = 7,
    kFeedbackSensorPID0 = 8,
    kFeedbackSensorPID1 = 9,
    kPolePairs = 10,
    kCurrentChop = 11,
    kCurrentChopCycles = 12,
    kP_0 = 13,
    kI_0 = 14,
    kD_0 = 15,
    kF_0 = 16,
    kIZone_0 = 17,
    kDFilter_0 = 18,
    kOutputMin_0 = 19,
    kOutputMax_0 = 20,
    kP_1 = 21,
    kI_1 = 22,
    kD_1 = 23,
    kF_1 = 24,
    kIZone_1 = 25,
    kDFilter_1 = 26,
    kOutputMin_1 = 27,
    kOutputMax_1 = 28,
    kP_2 = 29,
    kI_2 = 30,
    kD_2 = 31,
    kF_2 = 32,
    kIZone_2 = 33,
    kDFilter_2 = 34,
    kOutputMin_2 = 35,
    kOutputMax_2 = 36,
    kP_3 = 37,
    kI_3 = 38,
    kD_3 = 39,
    kF_3 = 40,
    kIZone_3 = 41,
    kDFilter_3 = 42,
    kOutputMin_3 = 43,
    kOutputMax_3 = 44,
    kInverted = 45,
    kOutputRatio = 46,
    kSerialNumberLow = 47,
    kSerialNumberMid = 48,
    kSerialNumberHigh = 49,
    kLimitSwitchFwdPolarity = 50,
    kLimitSwitchRevPolarity = 51,
    kHardLimitFwdEn = 52,
    kHardLimitRevEn = 53,
    kSoftLimitFwdEn = 54,
    kSoftLimitRevEn = 55,
    kRampRate = 56,
    kFollowerID = 57,
    kFollowerConfig = 58,
    kSmartCurrentStallLimit = 59,
    kSmartCurrentFreeLimit = 60,
    kSmartCurrentConfig = 61,
    kMotorKv = 63,
    kMotorR = 64,
    kMotorL = 65,
    kEncoderCountsPerRev = 69,
    kEncoderAverageDepth = 70,
    kEncoderSampleDelta = 71,
    kEncoderInverted = 72,
    kClosedLoopVoltageMode = 74,
    kCompensatedNominalVoltage = 75,
    kSmartMotionMaxVelocity_0 = 76,
    kSmartMotionMaxAccel_0 = 77,
    kSmartMotionMinVelOutput_0 = 78,
    kSmartMotionAllowedClosedLoopError_0 = 79,
    kSmartMotionAccelStrategy_0 = 80,
    kSmartMotionMaxVelocity_1 = 81,
    kSmartMotionMaxAccel_1 = 82,
    kSmartMotionMinVelOutput_1 = 83,
    kSmartMotionAllowedClosedLoopError_1 = 84,
    kSmartMotionAccelStrategy_1 = 85,
    kSmartMotionMaxVelocity_2 = 86,
    kSmartMotionMaxAccel_2 = 87,
    kSmartMotionMinVelOutput_2 = 88,
    kSmartMotionAllowedClosedLoopError_2 = 89,
    kSmartMotionAccelStrategy_2 = 90,
    kSmartMotionMaxVelocity_3 = 91,
    kSmartMotionMaxAccel_3 = 92,
    kSmartMotionMinVelOutput_3 = 93,
    kSmartMotionAllowedClosedLoopError_3 = 94,
    kSmartMotionAccelStrategy_3 = 95,
    kIMaxAccum_0 = 96,
    kSlot3Placeholder1_0 = 97,
    kSlot3Placeholder2_0 = 98,
    kSlot3Placeholder3_0 = 99,
    kIMaxAccum_1 = 100,
    kSlot3Placeholder1_1 = 101,
    kSlot3Placeholder2_1 = 102,
    kSlot3Placeholder3_1 = 103,
    kIMaxAccum_2 = 104,
    kSlot3Placeholder1_2 = 105,
    kSlot3Placeholder2_2 = 106,
    kSlot3Placeholder3_2 = 107,
    kIMaxAccum_3 = 108,
    kSlot3Placeholder1_3 = 109,
    kSlot3Placeholder2_3 = 110,
    kSlot3Placeholder3_3 = 111,
    kPositionConversionFactor = 112,
    kVelocityConversionFactor = 113,
    kClosedLoopRampRate = 114,
    kSoftLimitFwd = 115,
    kSoftLimitRev = 116,
    kAnalogPositionConversion = 119,
    kAnalogVelocityConversion = 120,
    kAnalogAverageDepth = 121,
    kAnalogSensorMode = 122,
    kAnalogInverted = 123,
    kAnalogSampleDelta = 124,
    kDataPortConfig = 127,
    kAltEncoderCountsPerRev = 128,
    kAltEncoderAverageDepth = 129,
    kAltEncoderSampleDelta = 130,
    kAltEncoderInverted = 131,
    kAltEncoderPositionFactor = 132,
    kAltEncoderVelocityFactor = 133,
    kHallSensorSampleRate = 136,
    kHallSensorAverageDepth = 137,
    kDutyCyclePositionFactor = 139,
    kDutyCycleVelocityFactor = 140,
    kDutyCycleInverted = 141,
    kDutyCycleAverageDepth = 143,
    kPositionPIDWrapEnable = 149,
    kPositionPIDMinInput = 150,
    kPositionPIDMaxInput = 151,
    kDutyCyclePrescalar = 153,
    kDutyCycleZeroOffset = 154
};

/**
 * @brief Periodic status 0 structure
 */
struct Period0Status
{
  float dutyCycle;
  uint16_t faults;
  uint16_t stickyFaults;
  bool isInverted;
  bool idleMode;
  bool isFollower;
  std::chrono::steady_clock::time_point timestamp;
};

/**
 * @brief Periodic status 1 structure
 */
struct Period1Status
{
  float velocity;
  float temperature;
  float voltage;
  float current;
  std::chrono::steady_clock::time_point timestamp;
};

/**
 * @brief Periodic status 2 structure
 */
struct Period2Status
{
  float position;
  float iAccum;
  std::chrono::steady_clock::time_point timestamp;
};

/**
 * @brief Periodic status 3 structure
 */
struct Period3Status
{
  float analogVoltage;
  float analogVelocity;
  float analogPosition;
  std::chrono::steady_clock::time_point timestamp;
};

/**
 * @brief Periodic status 4 structure
 */
struct Period4Status
{
  float altEncoderVelocity;
  float altEncoderPosition;
  std::chrono::steady_clock::time_point timestamp;
};

/**
 * A class designed to interface with DJI brand motors and motor controllers over CAN.
 * This includes the C610 and C620 motor controllers and the GM6020 motor (that has a
 * built-in motor controller).
 *
 * @note: the default positive rotation direction (i.e.: when `this->isMotorInverted()
 *      == false`) is counter clockwise when looking at the shaft from the side opposite
 *      the motor. This is specified in the C620 user manual (page 18).
 *
 * DJI motor encoders store a consistent encoding for a given angle across power-cycles.
 * This means the encoder angle reported by the motor can have meaning if the encoding
 * for an angle is unique as it is for the GM6020s. However for geared motors like the
 * M3508 where a full encoder revolution does not correspond 1:1 to a shaft revolution,
 * it is impossible to know the orientation of the shaft given just the encoder value.
 *
 * Extends the CanRxListener class to attach a message handler for feedback data from the
 * motor to the CAN Rx dispatch handler.
 *
 * @note Currently there is no error handling for using a motor without having it be properly
 * initialize. You must call the `initialize` function in order for this class to work properly.
 */
class RevMotor : public can::CanRxListener
{
public:
    // 0 - 8191 for dji motors
    // static constexpr uint16_t ENC_RESOLUTION = 42;

    /**
     * @param drivers a pointer to the drivers struct
     * @param desMotorIdentifier the ID of this motor controller
     * @param motorCanBus the CAN bus the motor is on
     * @param isInverted if `false` the positive rotation direction of the shaft is
     *      counter-clockwise when looking at the shaft from the side opposite the motor.
     *      If `true` then the positive rotation direction will be clockwise.
     * @param name a name to associate with the motor for use in the motor menu
     * @param encoderWrapped the starting encoderValue to store for this motor.
     *      Will be overwritten by the first reported encoder value from the motor
     * @param encoderRevolutions the starting number of encoder revolutions to store.
     *      See comment for RevMotor::encoderRevolutions for more details.
     */
    RevMotor(
        Drivers* drivers,
        REVMotorId desMotorIdentifier,
        tap::can::CanBus motorCanBus,
        bool isInverted,
        const char* name
        // uint16_t encoderWrapped = ENC_RESOLUTION / 2,
        // int64_t encoderRevolutions = 0
        );

    mockable ~RevMotor();

    void initialize();

    DISALLOW_COPY_AND_ASSIGN(RevMotor)

    // /**
    //  * Overrides virtual method in the can class, called every time a message with the
    //  * CAN message id this class is attached to is received by the can receive handler.
    //  * Parses the data in the message and updates this class's fields accordingly.
    //  *
    //  * @param[in] message the message to be processed.
    //  */
    void processMessage(const modm::can::Message& message);



    /**
     * @return the raw `desiredOutput` value which will be sent to the motor controller
     *      (specified via `setDesiredOutput()`)
     */

    mockable uint32_t getMotorIdentifier() const;

    mockable bool isMotorInverted() const { return motorInverted; };

    mockable tap::can::CanBus getCanBus() const;

    mockable const char* getName() const;


    void setTargetVoltage(float targetVoltage);












    /**
     * Control modes available for RevMotor operation
     */
    enum class ControlMode
    {
        DUTY_CYCLE,     // Direct duty cycle control (0.0 to 1.0)
        VELOCITY,       // Velocity control in RPM
        POSITION,       // Position control in rotations
        VOLTAGE,        // Voltage control in volts
        CURRENT,        // Current control in amps
        SMART_MOTION,   // Smart motion with acceleration and velocity limits
        SMART_VELOCITY  // Smart velocity with acceleration limits
    };

    APICommand controlModeToAPI(ControlMode mode);

    /**
     * Set the control mode for this motor
     * @param mode The desired control mode
     */
    void setControlMode(ControlMode mode);

    /**
     * Get the current control mode for this motor
     * @return The active control mode
     */
    ControlMode getControlMode() const;

    /**
     * Set the control value based on the current control mode
     * @param value The control value in appropriate units for the current mode
     */
    void setControlValue(float value);

    /**
     * Get the current control value
     * @return The control value in the units of the current mode
     */
    float getControlValue() const;

    float getPosition() const { return period2_.position; }
    float getVelocity() const { return isEncoderInverted ? -period1_.velocity : period1_.velocity; }

    /**
     * calculates the 29 bit ID for the REV Spark max motor controller. The basis for this is that in the
     * id is the control mode with some 28 bit number for a specific control mode like voltage or setpoint.
     * there is then an operation done to merge the devices CAN ID with the Messgae ID to create a message for
     * a specific motor controller
     */
    modm::can::Message createRevCanMessage(const RevMotor* motor);

    uint8_t GetAPIClass(APICommand cmd) const;
    uint8_t GetAPIIndex(APICommand cmd) const;

    uint32_t CreateArbitrationControlId(APICommand cmd, const RevMotor* motor) const;
    uint32_t CreateArbitrationParameterId(Parameter param, const RevMotor* motor) const;

    modm::can::Message constructRevMotorHeartBeat(const RevMotor* motor);

    void setParameter(Parameter param, float paramVal);

    void setEncoderInverted(bool isInverted)
    {
        isEncoderInverted = isInverted;
    }

private:

    const char* motorName;

    Drivers* drivers;

    uint32_t motorIdentifier;

    tap::can::CanBus motorCanBus;

    int16_t desiredOutput;

    float dutyCycle;

    float voltage;

    float current;

    float velocity;

    float position;

    float targetVoltage;

    bool motorInverted;

    bool isEncoderInverted;


    Period0Status period0_{};
    Period1Status period1_{};
    Period2Status period2_{};
    Period3Status period3_{};
    Period4Status period4_{};


    ControlMode currentControlMode = ControlMode::VOLTAGE;
    float controlValue = 0.0f;




    bool isControlAndNotParam;

    std::queue<std::pair<Parameter, float>> paramQueue;
    // std::queue<Parameter> parameters;
    // std::queue<float> paramVals;


};

}  // namespace tap::motor

#endif  // TAPROOT_DJI_MOTOR_HPP_
